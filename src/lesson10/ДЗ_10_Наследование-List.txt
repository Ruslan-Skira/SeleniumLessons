# Задачи на Объектно Ориентированное Программирование

=====================================================
Шилдт "Руководство для начинающих" 6 изд.
стр. 247-289
=====================================================
	
Задача для продвинутого уровня
	a) Описать интерфейс List, который содержит следующие методы:
			size(); 		// кол-во элементов 
			
			getFirst(); 	// возвращает первый элемент или null, если индекс за пределами диапазона
			getLast(); 		// возвращает последний или null, если индекс за пределами диапазона
			get(int index); // возвращает по индексу или null, если индекс за пределами диапазона
			
			set(int index, int element);  // устанавливает значение элемента по индексу index
			
			boolean contains(int element); 	// проверяет наличие элемента
			boolean isEmpty();				// проверяет, является ли список пустым
			
			addFirst(int element); 			// добавляет элемент в начало списка
			addLast(int element);  			// добавляет элемент в конец списка
			add(int index, int element); 	// добавляет элемент на позицию индекса index
			
			addFirst(List list);		// добавляет в начало все элементы из списка list
			addLast(List list);			// добавляет в конец все элементы из списка list
			add(int index, List list); 	// добавляет начиная с позиции index все элементы из списка list
			
			removeFirst();					// удаляет первый
			removeLast();					// удаляет последний
			remove(int index); 				// удаляет элемент по индексу
			removeAll(int element);			// удаляет все элементы, которые равны элемент
			removeRange(int from, int to); 	// удаляет все элементы из диапазона from, to - from влючительно, to - не включает
			removeAll(List list);			// удаляет все элементы из списка, если есть такой же есть в list
			
			indexOf(int element);			// возвращает индекс первого вхождения элемента
			lastIndexOf(int element); 		// возвращает индекс последнего вхождения элемента
			List subList(int from, int to); // возвращает часть списка, кот. содержит элементы начиная с индекса from включительно, и заканчивая 	индексом to (не включая)
			
			clear();	// очищает список
			inverse();  // переворачивает элементы наоборот (первый становится последним и т.д.)
			sort();		// сортирует все элементы
			
			min();  // возвращает минимальное значение элемента
			max(); 	// возвращает масимальное значение элемента
			avg(); 	// возвращает среднее значение элементов всего списка
	
	b) Создать абстрактный класс AbstractList имплементит интерфейс List
		- НЕ содержит поля для хранения данных 
		
		реализовать конструкторы:
			List() {}
			List(int[] array) {}
			List(List list) {}
		
		переопределить методы:
			equals();	// сравнивает два списка по содержимому
			toString(); // выводит строковое представление списка, напр.: [1, 6, -10, 45]
		
	c) Создать реализацию абстрактного класса AbstractList
		ArrayList extends AbstractList,
			который содержит поле - массив int[] elementData для хранения элементов
			
		- реализовать все абстрактные методы базового класса
		- проверить работу всех методов
		
	d)** Создать более эффективную реализацию абстрактного класса List
		ArrayEfficientList extends List,
			который содержит поле - массив int[] elementData для хранения элементов, 
			но при этом работа с этим полем оптимизирована. Это означает следующее:
				при добавлении элемента в список, нам придется каждый раз увеличивать размер массива,
				потем создании копии и переноса всех элементов. В этой реализации размер массива должен 
				быть изначально заданного размера, значение которого хранится в константном private поле: DEFAULT_CAPACITY;
				Если при операциях ввода размера массива не хватает, то размер увеличивается в 1.5 раза (с запасом для следующих операций)
				При удалении не уменьшать размер массива, а переносить все элементы в начало диапазона
				
			- реализовать дополнительный конструктор ArrayEfficientList(int capacity){};
					в котором мы можем указать желаемый изначальный размер массива
				
			- реализовать все абстрактные методы, учитывая введенную оптимизацию
			
			- проверить работу всех методов
					
	e)	Разработать класс Node который может быть использован, как двусвязный список:
			- содержит поля
				int item;   // значение
				Node next;	// следующий элемент списка
				Node prev;  // предыдущий предыдущий элемент списка
			
			- имеет конструктор:
				Node(Node prev, int item, Node next);
			
					
	f)* Создать реализацию абстрактного класса List на основе двусвязного списка:
		LinkedList extends List:
			который содержит в качестве хранилища данных двусвязный список, а именно начало на его первый элемент
			Для этого в качестве хранилища использовать класс Node			
					
			- реализовать все абстрактные методы		
			- проверить работу всех методов
			
	g) Внести изменения в реализацию классов, чтобы можно было хранить данные любого типа Object вместо int